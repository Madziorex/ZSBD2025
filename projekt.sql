----tworzenie tabel
CREATE TABLE pr_movies (
    movie_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title           VARCHAR2(100) NOT NULL,
    genre           VARCHAR2(50) NOT NULL,
    duration        NUMBER NOT NULL,
    premiere_date   DATE,
    age_restriction NUMBER
);

CREATE TABLE pr_cinemas (
    cinema_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name      VARCHAR2(100) NOT NULL,
    city      VARCHAR2(50)  NOT NULL,
    address   VARCHAR2(150),
    phone     VARCHAR2(20),
    email     VARCHAR2(100)
);

CREATE TABLE pr_halls (
    hall_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cinema_id    NUMBER NOT NULL,
    name_hall    VARCHAR2(50),

    CONSTRAINT pr_fk_halls_cinema
        FOREIGN KEY (cinema_id)
        REFERENCES pr_cinemas(cinema_id)
        ON DELETE CASCADE
);

CREATE TABLE pr_seats (
    seat_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    hall_id       NUMBER NOT NULL,
    row_number    NUMBER NOT NULL,
    column_number NUMBER NOT NULL,

    CONSTRAINT pr_fk_seats_hall
        FOREIGN KEY (hall_id)
        REFERENCES pr_halls(hall_id)
        ON DELETE CASCADE,

    CONSTRAINT pr_uq_seats_position
        UNIQUE (hall_id, row_number, column_number)
);

CREATE TABLE pr_screenings (
    screening_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    movie_id     NUMBER NOT NULL,
    hall_id      NUMBER NOT NULL,
    date_        DATE NOT NULL,
    time         VARCHAR2(5) NOT NULL,
    price        NUMBER(6,2) NOT NULL,

    CONSTRAINT pr_fk_screenings_movie
        FOREIGN KEY (movie_id)
        REFERENCES pr_movies(movie_id),

    CONSTRAINT pr_fk_screenings_hall
        FOREIGN KEY (hall_id)
        REFERENCES pr_halls(hall_id),

    CONSTRAINT pr_chk_screenings_price
        CHECK (price >= 0)
);

CREATE TABLE pr_clients (
    client_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name      VARCHAR2(50) NOT NULL,
    surname   VARCHAR2(50) NOT NULL,
    email     VARCHAR2(100),
    phone     VARCHAR2(20)
);

CREATE TABLE pr_tickets (
    ticket_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    screening_id NUMBER NOT NULL,
    seat_id      NUMBER NOT NULL,
    client_id    NUMBER NOT NULL,
    price        NUMBER(6,2) NOT NULL,
    status       VARCHAR2(20) NOT NULL,

    CONSTRAINT pr_fk_tickets_screening
        FOREIGN KEY (screening_id)
        REFERENCES pr_screenings(screening_id),

    CONSTRAINT pr_fk_tickets_seat
        FOREIGN KEY (seat_id)
        REFERENCES pr_seats(seat_id),

    CONSTRAINT pr_fk_tickets_client
        FOREIGN KEY (client_id)
        REFERENCES pr_clients(client_id),

    CONSTRAINT pr_uq_tickets_seat
        UNIQUE (screening_id, seat_id),

    CONSTRAINT pr_chk_tickets_status
        CHECK (status IN ('RESERVED', 'PAID', 'CANCELLED')),

    CONSTRAINT pr_chk_tickets_price
        CHECK (price >= 0)
);

CREATE TABLE pr_coupons (
    coupon_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code           VARCHAR2(30) NOT NULL,

    discount_type  VARCHAR2(10) NOT NULL,
    discount_value NUMBER(6,2) NOT NULL,
    valid_from     DATE,
    valid_to       DATE,
    is_active      CHAR(1) DEFAULT 'Y',

    CONSTRAINT pr_uq_coupons_code
        UNIQUE (code),

    CONSTRAINT pr_chk_coupons_type
        CHECK (discount_type IN ('PERCENT', 'AMOUNT')),

    CONSTRAINT pr_chk_coupons_active
        CHECK (is_active IN ('Y', 'N'))
);

CREATE TABLE pr_tickets_coupons (
    ticket_coupon_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ticket_id        NUMBER NOT NULL,
    coupon_id        NUMBER NOT NULL,

    CONSTRAINT pr_fk_tc_ticket
        FOREIGN KEY (ticket_id)
        REFERENCES pr_tickets(ticket_id)
        ON DELETE CASCADE,

    CONSTRAINT pr_fk_tc_coupon
        FOREIGN KEY (coupon_id)
        REFERENCES pr_coupons(coupon_id),

    CONSTRAINT pr_uq_tc_ticket
        UNIQUE (ticket_id)
);

CREATE TABLE pr_load_log (
    log_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    file_name     VARCHAR2(200) NOT NULL,
    load_date     DATE DEFAULT SYSDATE,
    status        VARCHAR2(20) NOT NULL,
    rows_loaded   NUMBER,
    error_message VARCHAR2(4000),

    CONSTRAINT pr_chk_load_status
        CHECK (status IN ('SUCCESS', 'ERROR'))
);

----2
ALTER TABLE pr_cinemas
ADD CONSTRAINT pr_uq_cinemas_city_address
UNIQUE (city, address);

--cinema
--add
CREATE OR REPLACE PROCEDURE pr_add_cinema (
    p_name    IN pr_cinemas.name%TYPE,
    p_city    IN pr_cinemas.city%TYPE,
    p_address IN pr_cinemas.address%TYPE,
    p_phone   IN pr_cinemas.phone%TYPE,
    p_email   IN pr_cinemas.email%TYPE
) AS
BEGIN
    INSERT INTO pr_cinemas (name, city, address, phone, email)
    VALUES (p_name, p_city, p_address, p_phone, p_email);

    COMMIT;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20001,
            'Kino pod tym adresem już istnieje w tym mieście'
        );

    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20099,
            'Nieoczekiwany błąd: ' || SQLERRM
        );
END pr_add_cinema;

--update
CREATE OR REPLACE PROCEDURE pr_update_cinema (
    p_cinema_id IN pr_cinemas.cinema_id%TYPE,
    p_name      IN pr_cinemas.name%TYPE,
    p_city      IN pr_cinemas.city%TYPE,
    p_address   IN pr_cinemas.address%TYPE,
    p_phone     IN pr_cinemas.phone%TYPE,
    p_email     IN pr_cinemas.email%TYPE
) AS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM pr_cinemas
    WHERE cinema_id = p_cinema_id;

    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(
            -20002,
            'Kino o podanym ID nie istnieje'
        );
    END IF;

    UPDATE pr_cinemas
    SET name    = p_name,
        city    = p_city,
        address = p_address,
        phone   = p_phone,
        email   = p_email
    WHERE cinema_id = p_cinema_id;

    COMMIT;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20003,
            'Kino pod tym adresem już istnieje w tym mieście'
        );

    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20099,
            'Błąd aktualizacji kina: ' || SQLERRM
        );
END pr_update_cinema;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_cinema (
    p_cinema_id IN pr_cinemas.cinema_id%TYPE
) AS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM pr_cinemas
    WHERE cinema_id = p_cinema_id;

    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(
            -20004,
            'Kino o podanym ID nie istnieje'
        );
    END IF;

    DELETE FROM pr_cinemas
    WHERE cinema_id = p_cinema_id;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20099,
            'Błąd usuwania kina: ' || SQLERRM
        );
END pr_delete_cinema;

--trigger achiwum cinema
CREATE OR REPLACE TRIGGER pr_trg_cinemas_arch
BEFORE DELETE ON pr_cinemas
FOR EACH ROW
BEGIN
    INSERT INTO pr_cinemas_arch (
        cinema_id,
        name,
        city,
        address,
        phone,
        email,
        deleted_at,
        deleted_by
    )
    VALUES (
        :OLD.cinema_id,
        :OLD.name,
        :OLD.city,
        :OLD.address,
        :OLD.phone,
        :OLD.email,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_cinemas_log
AFTER INSERT OR UPDATE OR DELETE ON pr_cinemas
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_CINEMAS', 'INSERT', :NEW.cinema_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_CINEMAS', 'UPDATE', :NEW.cinema_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_CINEMAS', 'DELETE', :OLD.cinema_id, USER);
    END IF;
END;

--movies
--archiwizacja
CREATE OR REPLACE TRIGGER pr_trg_movies_arch
BEFORE DELETE ON pr_movies
FOR EACH ROW
BEGIN
    INSERT INTO pr_movies_arch (
        movie_id, title, genre, duration,
        premiere_date, age_restriction,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.movie_id,
        :OLD.title,
        :OLD.genre,
        :OLD.duration,
        :OLD.premiere_date,
        :OLD.age_restriction,
        SYSDATE,
        USER
    );
END;

CREATE OR REPLACE TRIGGER pr_trg_movies_log
AFTER INSERT OR UPDATE OR DELETE ON pr_movies
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_MOVIES', 'INSERT', :NEW.movie_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_MOVIES', 'UPDATE', :NEW.movie_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_MOVIES', 'DELETE', :OLD.movie_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_movie (
    p_title          IN pr_movies.title%TYPE,
    p_genre          IN pr_movies.genre%TYPE,
    p_duration       IN pr_movies.duration%TYPE,
    p_premiere_date  IN pr_movies.premiere_date%TYPE,
    p_age_restriction IN pr_movies.age_restriction%TYPE
) AS
BEGIN
    INSERT INTO pr_movies (
        title, genre, duration, premiere_date, age_restriction
    )
    VALUES (
        p_title, p_genre, p_duration, p_premiere_date, p_age_restriction
    );

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20101, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_movie (
    p_movie_id       IN pr_movies.movie_id%TYPE,
    p_title          IN pr_movies.title%TYPE,
    p_genre          IN pr_movies.genre%TYPE,
    p_duration       IN pr_movies.duration%TYPE,
    p_premiere_date  IN pr_movies.premiere_date%TYPE,
    p_age_restriction IN pr_movies.age_restriction%TYPE
) AS
BEGIN
    UPDATE pr_movies
    SET title = p_title,
        genre = p_genre,
        duration = p_duration,
        premiere_date = p_premiere_date,
        age_restriction = p_age_restriction
    WHERE movie_id = p_movie_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20102, 'Film nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20103, SQLERRM);
END;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_movie (
    p_movie_id IN pr_movies.movie_id%TYPE
) AS
BEGIN
    DELETE FROM pr_movies
    WHERE movie_id = p_movie_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20104, 'Film nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20105, SQLERRM);
END;

--halls
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_halls_arch
BEFORE DELETE ON pr_halls
FOR EACH ROW
BEGIN
    INSERT INTO pr_halls_arch (
        hall_id, cinema_id, name_hall,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.hall_id,
        :OLD.cinema_id,
        :OLD.name_hall,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_halls_log
AFTER INSERT OR UPDATE OR DELETE ON pr_halls
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_HALLS', 'INSERT', :NEW.hall_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_HALLS', 'UPDATE', :NEW.hall_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_HALLS', 'DELETE', :OLD.hall_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_hall (
    p_cinema_id   IN pr_halls.cinema_id%TYPE,
    p_name_hall   IN pr_halls.name_hall%TYPE
) AS
BEGIN
    INSERT INTO pr_halls (cinema_id, name_hall)
    VALUES (p_cinema_id, p_name_hall);

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20201, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_hall (
    p_hall_id      IN pr_halls.hall_id%TYPE,
    p_cinema_id    IN pr_halls.cinema_id%TYPE,
    p_name_hall    IN pr_halls.name_hall%TYPE
) AS
BEGIN
    UPDATE pr_halls
    SET cinema_id = p_cinema_id,
        name_hall = p_name_hall
    WHERE hall_id = p_hall_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20202, 'Sala nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20203, SQLERRM);
END;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_hall (
    p_hall_id IN pr_halls.hall_id%TYPE
) AS
BEGIN
    DELETE FROM pr_halls
    WHERE hall_id = p_hall_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20204, 'Sala nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20205, SQLERRM);
END;

--seats
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_seats_arch
BEFORE DELETE ON pr_seats
FOR EACH ROW
BEGIN
    INSERT INTO pr_seats_arch (
        seat_id, hall_id, row_number, column_number,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.seat_id,
        :OLD.hall_id,
        :OLD.row_number,
        :OLD.column_number,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_seats_log
AFTER INSERT OR UPDATE OR DELETE ON pr_seats
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_SEATS', 'INSERT', :NEW.seat_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_SEATS', 'UPDATE', :NEW.seat_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_SEATS', 'DELETE', :OLD.seat_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_seat (
    p_hall_id       IN pr_seats.hall_id%TYPE,
    p_row_number    IN pr_seats.row_number%TYPE,
    p_column_number IN pr_seats.column_number%TYPE
) AS
BEGIN
    INSERT INTO pr_seats (hall_id, row_number, column_number)
    VALUES (p_hall_id, p_row_number, p_column_number);

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20301, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_seat (
    p_seat_id       IN pr_seats.seat_id%TYPE,
    p_hall_id       IN pr_seats.hall_id%TYPE,
    p_row_number    IN pr_seats.row_number%TYPE,
    p_column_number IN pr_seats.column_number%TYPE
) AS
BEGIN
    UPDATE pr_seats
    SET hall_id = p_hall_id,
        row_number = p_row_number,
        column_number = p_column_number
    WHERE seat_id = p_seat_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20302, 'Miejsce nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20303, SQLERRM);
END;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_seat (
    p_seat_id IN pr_seats.seat_id%TYPE
) AS
BEGIN
    DELETE FROM pr_seats
    WHERE seat_id = p_seat_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20304, 'Miejsce nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20305, SQLERRM);
END;

--screenings
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_screenings_arch
BEFORE DELETE ON pr_screenings
FOR EACH ROW
BEGIN
    INSERT INTO pr_screenings_arch (
        screening_id, movie_id, hall_id, date_, time, price,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.screening_id,
        :OLD.movie_id,
        :OLD.hall_id,
        :OLD.date_,
        :OLD.time,
        :OLD.price,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_screenings_log
AFTER INSERT OR UPDATE OR DELETE ON pr_screenings
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_SCREENINGS', 'INSERT', :NEW.screening_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_SCREENINGS', 'UPDATE', :NEW.screening_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_SCREENINGS', 'DELETE', :OLD.screening_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_screening (
    p_movie_id IN pr_screenings.movie_id%TYPE,
    p_hall_id  IN pr_screenings.hall_id%TYPE,
    p_date     IN pr_screenings.date_%TYPE,
    p_time     IN pr_screenings.time%TYPE,
    p_price    IN pr_screenings.price%TYPE
) AS
BEGIN
    INSERT INTO pr_screenings (movie_id, hall_id, date_, time, price)
    VALUES (p_movie_id, p_hall_id, p_date, p_time, p_price);

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20401, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_screening (
    p_screening_id IN pr_screenings.screening_id%TYPE,
    p_movie_id     IN pr_screenings.movie_id%TYPE,
    p_hall_id      IN pr_screenings.hall_id%TYPE,
    p_date         IN pr_screenings.date_%TYPE,
    p_time         IN pr_screenings.time%TYPE,
    p_price        IN pr_screenings.price%TYPE
) AS
BEGIN
    UPDATE pr_screenings
    SET movie_id = p_movie_id,
        hall_id  = p_hall_id,
        date_    = p_date,
        time     = p_time,
        price    = p_price
    WHERE screening_id = p_screening_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20402, 'Seans nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20403, SQLERRM);
END;

---delete
CREATE OR REPLACE PROCEDURE pr_delete_screening (
    p_screening_id IN pr_screenings.screening_id%TYPE
) AS
BEGIN
    DELETE FROM pr_screenings
    WHERE screening_id = p_screening_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20404, 'Seans nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20405, SQLERRM);
END;

--tickets
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_tickets_arch
BEFORE DELETE ON pr_tickets
FOR EACH ROW
BEGIN
    INSERT INTO pr_tickets_arch (
        ticket_id, screening_id, seat_id, client_id,
        price, status, deleted_at, deleted_by
    )
    VALUES (
        :OLD.ticket_id,
        :OLD.screening_id,
        :OLD.seat_id,
        :OLD.client_id,
        :OLD.price,
        :OLD.status,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_tickets_log
AFTER INSERT OR UPDATE OR DELETE ON pr_tickets
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_TICKETS', 'INSERT', :NEW.ticket_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_TICKETS', 'UPDATE', :NEW.ticket_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_TICKETS', 'DELETE', :OLD.ticket_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_ticket (
    p_screening_id IN pr_tickets.screening_id%TYPE,
    p_seat_id      IN pr_tickets.seat_id%TYPE,
    p_client_id    IN pr_tickets.client_id%TYPE,
    p_price        IN pr_tickets.price%TYPE,
    p_status       IN pr_tickets.status%TYPE
) AS
BEGIN
    INSERT INTO pr_tickets (
        screening_id, seat_id, client_id, price, status
    )
    VALUES (
        p_screening_id, p_seat_id, p_client_id, p_price, p_status
    );

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20501, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_ticket (
    p_ticket_id    IN pr_tickets.ticket_id%TYPE,
    p_screening_id IN pr_tickets.screening_id%TYPE,
    p_seat_id      IN pr_tickets.seat_id%TYPE,
    p_client_id    IN pr_tickets.client_id%TYPE,
    p_price        IN pr_tickets.price%TYPE,
    p_status       IN pr_tickets.status%TYPE
) AS
BEGIN
    UPDATE pr_tickets
    SET screening_id = p_screening_id,
        seat_id      = p_seat_id,
        client_id    = p_client_id,
        price        = p_price,
        status       = p_status
    WHERE ticket_id = p_ticket_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20502, 'Bilet nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20503, SQLERRM);
END;


--delete
CREATE OR REPLACE PROCEDURE pr_delete_ticket (
    p_ticket_id IN pr_tickets.ticket_id%TYPE
) AS
BEGIN
    DELETE FROM pr_tickets
    WHERE ticket_id = p_ticket_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20504, 'Bilet nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20505, SQLERRM);
END;

--clients
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_clients_arch
BEFORE DELETE ON pr_clients
FOR EACH ROW
BEGIN
    INSERT INTO pr_clients_arch (
        client_id, name, surname, email, phone,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.client_id,
        :OLD.name,
        :OLD.surname,
        :OLD.email,
        :OLD.phone,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_clients_log
AFTER INSERT OR UPDATE OR DELETE ON pr_clients
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_CLIENTS', 'INSERT', :NEW.client_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_CLIENTS', 'UPDATE', :NEW.client_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_CLIENTS', 'DELETE', :OLD.client_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_client (
    p_name    IN pr_clients.name%TYPE,
    p_surname IN pr_clients.surname%TYPE,
    p_email   IN pr_clients.email%TYPE,
    p_phone   IN pr_clients.phone%TYPE
) AS
BEGIN
    INSERT INTO pr_clients (name, surname, email, phone)
    VALUES (p_name, p_surname, p_email, p_phone);

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20701, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_client (
    p_client_id IN pr_clients.client_id%TYPE,
    p_name      IN pr_clients.name%TYPE,
    p_surname   IN pr_clients.surname%TYPE,
    p_email     IN pr_clients.email%TYPE,
    p_phone     IN pr_clients.phone%TYPE
) AS
BEGIN
    UPDATE pr_clients
    SET name    = p_name,
        surname = p_surname,
        email   = p_email,
        phone   = p_phone
    WHERE client_id = p_client_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20702, 'Klient nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20703, SQLERRM);
END;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_client (
    p_client_id IN pr_clients.client_id%TYPE
) AS
BEGIN
    DELETE FROM pr_clients
    WHERE client_id = p_client_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20704, 'Klient nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20705, SQLERRM);
END;

--coupons
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_coupons_arch
BEFORE DELETE ON pr_coupons
FOR EACH ROW
BEGIN
    INSERT INTO pr_coupons_arch (
        coupon_id, code, discount_type, discount_value,
        valid_from, valid_to, is_active,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.coupon_id,
        :OLD.code,
        :OLD.discount_type,
        :OLD.discount_value,
        :OLD.valid_from,
        :OLD.valid_to,
        :OLD.is_active,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_coupons_log
AFTER INSERT OR UPDATE OR DELETE ON pr_coupons
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_COUPONS', 'INSERT', :NEW.coupon_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_COUPONS', 'UPDATE', :NEW.coupon_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_COUPONS', 'DELETE', :OLD.coupon_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_coupon (
    p_code           IN pr_coupons.code%TYPE,
    p_discount_type  IN pr_coupons.discount_type%TYPE,
    p_discount_value IN pr_coupons.discount_value%TYPE,
    p_valid_from     IN pr_coupons.valid_from%TYPE,
    p_valid_to       IN pr_coupons.valid_to%TYPE,
    p_is_active      IN pr_coupons.is_active%TYPE
) AS
BEGIN
    INSERT INTO pr_coupons (
        code, discount_type, discount_value,
        valid_from, valid_to, is_active
    )
    VALUES (
        p_code, p_discount_type, p_discount_value,
        p_valid_from, p_valid_to, p_is_active
    );

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20801, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_coupon (
    p_coupon_id      IN pr_coupons.coupon_id%TYPE,
    p_code           IN pr_coupons.code%TYPE,
    p_discount_type  IN pr_coupons.discount_type%TYPE,
    p_discount_value IN pr_coupons.discount_value%TYPE,
    p_valid_from     IN pr_coupons.valid_from%TYPE,
    p_valid_to       IN pr_coupons.valid_to%TYPE,
    p_is_active      IN pr_coupons.is_active%TYPE
) AS
BEGIN
    UPDATE pr_coupons
    SET code           = p_code,
        discount_type  = p_discount_type,
        discount_value = p_discount_value,
        valid_from     = p_valid_from,
        valid_to       = p_valid_to,
        is_active      = p_is_active
    WHERE coupon_id = p_coupon_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20802, 'Kupon nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20803, SQLERRM);
END;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_coupon (
    p_coupon_id IN pr_coupons.coupon_id%TYPE
) AS
BEGIN
    DELETE FROM pr_coupons
    WHERE coupon_id = p_coupon_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20804, 'Kupon nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20805, SQLERRM);
END;

--tickets_coupons
--archiwum
CREATE OR REPLACE TRIGGER pr_trg_tc_arch
BEFORE DELETE ON pr_tickets_coupons
FOR EACH ROW
BEGIN
    INSERT INTO pr_tickets_coupons_arch (
        ticket_coupon_id, ticket_id, coupon_id,
        deleted_at, deleted_by
    )
    VALUES (
        :OLD.ticket_coupon_id,
        :OLD.ticket_id,
        :OLD.coupon_id,
        SYSDATE,
        USER
    );
END;

--logowanie
CREATE OR REPLACE TRIGGER pr_trg_tc_log
AFTER INSERT OR UPDATE OR DELETE ON pr_tickets_coupons
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_TICKETS_COUPONS', 'INSERT', :NEW.ticket_coupon_id, USER);

    ELSIF UPDATING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_TICKETS_COUPONS', 'UPDATE', :NEW.ticket_coupon_id, USER);

    ELSIF DELETING THEN
        INSERT INTO pr_action_log
            (table_name, action_type, record_id, user_name)
        VALUES
            ('PR_TICKETS_COUPONS', 'DELETE', :OLD.ticket_coupon_id, USER);
    END IF;
END;

--add
CREATE OR REPLACE PROCEDURE pr_add_ticket_coupon (
    p_ticket_id IN pr_tickets_coupons.ticket_id%TYPE,
    p_coupon_id IN pr_tickets_coupons.coupon_id%TYPE
) AS
BEGIN
    INSERT INTO pr_tickets_coupons (ticket_id, coupon_id)
    VALUES (p_ticket_id, p_coupon_id);

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20901, SQLERRM);
END;

--update
CREATE OR REPLACE PROCEDURE pr_update_ticket_coupon (
    p_ticket_coupon_id IN pr_tickets_coupons.ticket_coupon_id%TYPE,
    p_ticket_id        IN pr_tickets_coupons.ticket_id%TYPE,
    p_coupon_id        IN pr_tickets_coupons.coupon_id%TYPE
) AS
BEGIN
    UPDATE pr_tickets_coupons
    SET ticket_id = p_ticket_id,
        coupon_id = p_coupon_id
    WHERE ticket_coupon_id = p_ticket_coupon_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20902, 'Powiązanie nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20903, SQLERRM);
END;

--delete
CREATE OR REPLACE PROCEDURE pr_delete_ticket_coupon (
    p_ticket_coupon_id IN pr_tickets_coupons.ticket_coupon_id%TYPE
) AS
BEGIN
    DELETE FROM pr_tickets_coupons
    WHERE ticket_coupon_id = p_ticket_coupon_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20904, 'Powiązanie nie istnieje');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20905, SQLERRM);
END;

----exceptions
--pr_exc_seat_already_taken
CREATE OR REPLACE PROCEDURE pr_add_ticket (
    p_screening_id IN pr_tickets.screening_id%TYPE,
    p_seat_id      IN pr_tickets.seat_id%TYPE,
    p_client_id    IN pr_tickets.client_id%TYPE,
    p_price        IN pr_tickets.price%TYPE,
    p_status       IN pr_tickets.status%TYPE
) AS
    v_count NUMBER;

    pr_exc_seat_already_taken EXCEPTION;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM pr_tickets
    WHERE screening_id = p_screening_id
      AND seat_id = p_seat_id;

    IF v_count > 0 THEN
        RAISE pr_exc_seat_already_taken;
    END IF;

    INSERT INTO pr_tickets (
        screening_id, seat_id, client_id, price, status
    )
    VALUES (
        p_screening_id, p_seat_id, p_client_id, p_price, p_status
    );

    COMMIT;

EXCEPTION
    WHEN pr_exc_seat_already_taken THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20001,
            'Miejsce jest już zajęte na ten seans'
        );

    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-21099, SQLERRM);
END;

--pr_exc_invalid_screening_date
CREATE OR REPLACE PROCEDURE pr_add_screening (
    p_movie_id IN pr_screenings.movie_id%TYPE,
    p_hall_id  IN pr_screenings.hall_id%TYPE,
    p_date     IN pr_screenings.date_%TYPE,
    p_time     IN pr_screenings.time%TYPE,
    p_price    IN pr_screenings.price%TYPE
) AS
    pr_exc_invalid_screening_date EXCEPTION;
BEGIN
    IF p_date < TRUNC(SYSDATE) THEN
        RAISE pr_exc_invalid_screening_date;
    END IF;

    INSERT INTO pr_screenings (movie_id, hall_id, date_, time, price)
    VALUES (p_movie_id, p_hall_id, p_date, p_time, p_price);

    COMMIT;

EXCEPTION
    WHEN pr_exc_invalid_screening_date THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20002,
            'Nie można dodać seansu w przeszłości'
        );

    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20099, SQLERRM);
END;


--pr_exc_screening_sold_out
CREATE OR REPLACE PROCEDURE pr_add_ticket (
    p_screening_id IN pr_tickets.screening_id%TYPE,
    p_seat_id      IN pr_tickets.seat_id%TYPE,
    p_client_id    IN pr_tickets.client_id%TYPE,
    p_price        IN pr_tickets.price%TYPE,
    p_status       IN pr_tickets.status%TYPE
) AS
    v_taken_seat_count NUMBER;

    pr_exc_seat_already_taken EXCEPTION;
BEGIN
    SELECT COUNT(*)
    INTO v_taken_seat_count
    FROM pr_tickets
    WHERE screening_id = p_screening_id
      AND seat_id      = p_seat_id;

    IF v_taken_seat_count > 0 THEN
        RAISE pr_exc_seat_already_taken;
    END IF;

    INSERT INTO pr_tickets (
        screening_id, seat_id, client_id, price, status
    )
    VALUES (
        p_screening_id, p_seat_id, p_client_id, p_price, p_status
    );

    COMMIT;

EXCEPTION
    WHEN pr_exc_seat_already_taken THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(
            -20001,
            'Miejsce jest już zajęte na ten seans'
        );

    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20099, SQLERRM);
END;

--funkcje obsługujące kupony
--czy jest aktywny
CREATE OR REPLACE FUNCTION pr_is_coupon_valid (
    p_coupon_code IN pr_coupons.code%TYPE
) RETURN NUMBER
AS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM pr_coupons
    WHERE code = p_coupon_code
      AND is_active = 'Y'
      AND (valid_from IS NULL OR valid_from <= SYSDATE)
      AND (valid_to   IS NULL OR valid_to   >= SYSDATE);

    IF v_count = 0 THEN
        RETURN 0;
    END IF;

    RETURN 1;
END;

--liczenie ceny
CREATE OR REPLACE FUNCTION pr_apply_coupon (
    p_price       IN NUMBER,
    p_coupon_code IN pr_coupons.code%TYPE
) RETURN NUMBER
AS
    v_type   pr_coupons.discount_type%TYPE;
    v_value  pr_coupons.discount_value%TYPE;
    v_price  NUMBER;
BEGIN
    SELECT discount_type, discount_value
    INTO v_type, v_value
    FROM pr_coupons
    WHERE code = p_coupon_code;

    IF v_type = 'PERCENT' THEN
        v_price := p_price * (1 - v_value / 100);
    ELSIF v_type = 'AMOUNT' THEN
        v_price := p_price - v_value;
    END IF;

    IF v_price < 0 THEN
        v_price := 0;
    END IF;

    RETURN v_price;
END;


--kupowanie biletu
CREATE OR REPLACE PROCEDURE pr_buy_ticket (
    p_screening_id IN pr_tickets.screening_id%TYPE,
    p_seat_id      IN pr_tickets.seat_id%TYPE,
    p_client_id    IN pr_tickets.client_id%TYPE,
    p_coupon_code  IN pr_coupons.code%TYPE DEFAULT NULL,
    p_status       IN pr_tickets.status%TYPE DEFAULT 'RESERVED'
) AS
    v_ticket_id   pr_tickets.ticket_id%TYPE;
    v_base_price  pr_screenings.price%TYPE;
    v_final_price NUMBER;
    v_coupon_id   pr_coupons.coupon_id%TYPE;
BEGIN
    SELECT price
    INTO v_base_price
    FROM pr_screenings
    WHERE screening_id = p_screening_id;

    v_final_price := v_base_price;

    IF p_coupon_code IS NOT NULL THEN
        IF pr_is_coupon_valid(p_coupon_code) = 0 THEN
            RAISE_APPLICATION_ERROR(-20601, 'Niepoprawny lub nieaktywny kupon');
        END IF;

        v_final_price := pr_apply_coupon(v_base_price, p_coupon_code);

        SELECT coupon_id
        INTO v_coupon_id
        FROM pr_coupons
        WHERE code = p_coupon_code;
    END IF;

    pr_add_ticket(
        p_screening_id,
        p_seat_id,
        p_client_id,
        v_final_price,
        p_status
    );

    SELECT MAX(ticket_id)
    INTO v_ticket_id
    FROM pr_tickets
    WHERE screening_id = p_screening_id
      AND seat_id      = p_seat_id
      AND client_id    = p_client_id;

    IF p_coupon_code IS NOT NULL THEN
        INSERT INTO pr_tickets_coupons (ticket_id, coupon_id)
        VALUES (v_ticket_id, v_coupon_id);
    END IF;

    COMMIT;
END;

--funkcja okienkowa obłożenie seansu
--widok
CREATE OR REPLACE VIEW pr_screening_sold_seats AS
SELECT DISTINCT
    screening_id,
    sold_seats
FROM (
    SELECT
        s.screening_id,
        COUNT(t.ticket_id)
            OVER (PARTITION BY s.screening_id) AS sold_seats
    FROM pr_screenings s
    LEFT JOIN pr_tickets t
        ON t.screening_id = s.screening_id
);

----f
--funkcja sprawdzająca email
CREATE OR REPLACE FUNCTION pr_is_email_valid (
    p_email IN pr_clients.email%TYPE
) RETURN NUMBER
AS
BEGIN
    IF p_email IS NULL THEN
        RETURN 1;
    END IF;

    IF REGEXP_LIKE(p_email, '^[^@]+@[^@]+\.[^@]+$') THEN
        RETURN 1;
    END IF;

    RETURN 0;
END;

--funckja sprawdzajaca telefon
CREATE OR REPLACE FUNCTION pr_is_phone_valid (
    p_phone IN pr_clients.phone%TYPE
) RETURN NUMBER
AS
BEGIN
    IF p_phone IS NULL THEN
        RETURN 1;
    END IF;

    IF REGEXP_LIKE(p_phone, '^[0-9]{9}$') THEN
        RETURN 1;
    END IF;

    RETURN 0;
END;

--trigger
CREATE OR REPLACE TRIGGER pr_trg_clients_validate
BEFORE INSERT OR UPDATE ON pr_clients
FOR EACH ROW
BEGIN
    IF pr_is_email_valid(:NEW.email) = 0 THEN
        RAISE_APPLICATION_ERROR(
            -20001,
            'Niepoprawny adres email'
        );
    END IF;

    IF pr_is_phone_valid(:NEW.phone) = 0 THEN
        RAISE_APPLICATION_ERROR(
            -20002,
            'Niepoprawny numer telefonu'
        );
    END IF;
END;

----4
--tabela
CREATE TABLE pr_sales_summary (
    summary_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    period_type   VARCHAR2(10) NOT NULL,
    period_start  DATE NOT NULL,
    period_end DATE NOT NULL,
    tickets_sold  NUMBER NOT NULL,
    total_amount  NUMBER(10,2) NOT NULL,
    created_at    DATE DEFAULT SYSDATE
);

--procedura
CREATE OR REPLACE PROCEDURE pr_generate_sales_summary (
    p_period_type IN pr_sales_summary.period_type%TYPE,
    p_date_from   IN DATE
) AS
    v_date_to       DATE;
    v_tickets_sold  NUMBER;
    v_total_amount  NUMBER(10,2);
BEGIN
    IF p_period_type = 'MONTH' THEN
        v_date_to := ADD_MONTHS(p_date_from, 1);
    ELSIF p_period_type = 'QUARTER' THEN
        v_date_to := ADD_MONTHS(p_date_from, 3);
    ELSIF p_period_type = 'YEAR' THEN
        v_date_to := ADD_MONTHS(p_date_from, 12);
    ELSE
        RAISE_APPLICATION_ERROR(-20031, 'Niepoprawny typ okresu');
    END IF;

    SELECT
        COUNT(t.ticket_id),
        NVL(SUM(t.price), 0)
    INTO
        v_tickets_sold,
        v_total_amount
    FROM pr_tickets t
    JOIN pr_screenings s
        ON s.screening_id = t.screening_id
    WHERE s.date_ >= p_date_from
      AND s.date_ <  v_date_to
      AND t.status = 'PAID';

    INSERT INTO pr_sales_summary (
        period_type,
        period_start,
        period_end,
        tickets_sold,
        total_amount
    )
    VALUES (
        p_period_type,
        p_date_from,
        v_date_to,
        v_tickets_sold,
        v_total_amount
    );

    COMMIT;
END;

--przykład użycia
BEGIN
    pr_generate_sales_summary('MONTH', DATE '2026-01-30');
END;
